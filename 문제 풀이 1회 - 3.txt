31. 다음 중 파티션에 대한 설명으로 올바르지 않은 것은?
1. RANK() OVER (PPARTITION BY JOB ORDER BY SAL ASC) JOB_RANK
 : 각 JOB 별 SAL이 낮은 순서대로 순위가 부여된다.
2. SUM(SAL) OVER(PARTITION BY MGR ORDER BY SAL RANGE UNBOUNDED PRECEDING)
 : 각 MGR별 현재 행부터 파티션 내 첫번째 행까지의 SAL의 합계를 계산한다.
3. COUNT(*) OVER(ORDER BY SAL) RANGE BETWEEN 10 PRECEDING AND 150 FOLLOWING)
 : SAL을 기준으로 현재 행에서의 SAL의 -10에서 +150 사이의 급여를 가지는 행의 수를 계산한다.
4. AVG(SAL) OVER (PARTITION BY MGR ORDER BY TODAY ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
 : 각 MGR 별로 앞의 한 건, 현재 행, 뒤의 한 건 사이에서 SAL의 평균을 계산한다.
답 : 4번
해설) 4번 보기는 각 MGR 별로 SAL의 평균을 계산하기 전에 TODAY를 기준으로 정렬을 수행한 다음에 
SAL의 평균을 계산한다. 즉, 각 MGR별 TODAY 기준으로 정렬하였을 때 파티션 내에서 앞의 한 건, 
핸재 행, 뒤의 한 건 사이의 급여의 평균을 계산한다.

32. 다음에서 주어진 Mytest 테이블에서 SQL문을 실행했을 때 결괏값과 같은 SQL문은?(단 UNION은 정렬도 진행하는 것으로 한다)
Mytest 테이블 JOB_ID [ manager, manager, manager, helper, helper, helper ], SALARY [1300, 1500, 1900, 1000, 1500, 2500]
결과 JOB_ID [helper, helper, manager, manager], SALARY [1000, 2500, 1300, 1900]
1. SELECT *
FROM (SELECT JOB_ID, MAX(SALARY) 
FROM Mytest 
GROUP BY JOB_ID UNION
SELECT JOB_ID, MIN(SALARY) 
FROM Mytest
GROUP BY JOB_ID);
2. SELECT *
FROM (SELECT JOB_ID, MAX(SALARY) 
FROM Mytest 
GROUP BY SALARY UNION
SELECT JOB_ID, MIN(SALARY) 
FROM Mytest
GROUP BY SALARY);
3. SELECT *
FROM (SELECT JOB_ID, MAX(SALARY) 
FROM Mytest 
GROUP BY JOB_ID UNION ALL
SELECT JOB_ID, MIN(SALARY) 
FROM Mytest
GROUP BY JOB_ID);
4. SELECT *
FROM (SELECT JOB_ID, MAX(SALARY) 
FROM Mytest 
GROUP BY SALARY UNION ALL
SELECT JOB_ID, MIN(SALARY) 
FROM Mytest
GROUP BY SALARY);
답 : 1번
해설) UNION ALL은 중복제거 안하고 정렬도 안함

33. 다음 보기의 SQL문을 실행했을 때 결과값이 다른 하나는?
Mytest 테이블 COL1 [NULL, 0, NULL, 0, NULL]
1. SELECT CASE A, COL1 WHEN NULL THEN -1 ELSE 0
END AS DATA FROM Mytest A;
2. SELECT CASE WHEN A, COL1 IS NULL THEN -1 ELSE 0
END AS DATA FROM Mytest A;
3. SELECT DECODE(A, COL1, NULL, -1, A.col1)
AS DATA FROM Mytest A;
4. SELECT NVL(A.col1, -1)
AS DATA FROM Mytest A;
